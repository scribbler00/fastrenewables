# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_tabular.data.ipynb (unless otherwise specified).

__all__ = ['RenewableDataLoaders']

# Cell
from fastai.torch_basics import *
from fastai.data.all import *
from fastai.tabular.data import *
from fastai.tabular.core import *
from .core import *
import glob

# Cell
class RenewableDataLoaders(DataLoaders):
    "A dataloader for `fastrenewables` tabular data."
    @classmethod
    @delegates(Tabular.dataloaders, but=["dl_type", "dl_kwargs"])
    def from_df(cls, df, path='.', procs=None, pre_procs=None, cat_names=None, cont_names=None, y_names=None, y_block=None,
                splits=None, **kwargs):

        "Create from `df` in `path` using `procs`"
        if cat_names is None: cat_names = []
        if cont_names is None: cont_names = list(set(df)-set(L(cat_names))-set(L(y_names)))

        if pre_procs is None: pre_procs = [
            CreateTimeStampIndex("TimeUTC"),
                AddSeasonalFeatures,
            ]
        if procs is None:
            procs = [
                NormalizePerTask,
                    Categorify]


        splits = RandomSplitter(valid_pct=0.2) if splits is None else splits
        to = TabularRenewables(
            df,
            cont_names=cont_names,
            cat_names=cat_names,
            y_names=y_names,
            pre_process=pre_procs,
            procs=procs,
            splits=splits,
        )


        return to.dataloaders(path=path, **kwargs)


    @classmethod
    def from_files(cls, files, **kwargs):
        dfs = read_files(files)

        dfs = pd.concat(dfs, axis=0)
#         if "cat_names" in kwargs.keys():
#             kwargs["cat_names"] = kwargs["cat_names"] if "TaskID" in kwargs["cat_names"] else kwargs["cat_names"] + ["TaskID"]
#         else:
#             kwargs["cat_names"] = ["TaskID"]

        return cls.from_df(dfs, **kwargs)