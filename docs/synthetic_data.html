---

title: Title


keywords: fastai
sidebar: home_sidebar



nb_path: "nbs/00g_synthetic_data.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/00g_synthetic_data.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="plot_class_hists" class="doc_header"><code>plot_class_hists</code><a href="https://github.com/scribbler00/fastrenewables/tree/master/fastrenewables/synthetic_data.py#L16" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>plot_class_hists</code>(<strong><code>x_cat</code></strong>, <strong><code>x_cont</code></strong>, <strong><code>bandwidth</code></strong>=<em><code>0.04</code></em>, <strong><code>figsize</code></strong>=<em><code>(16, 9)</code></em>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="fit_kde" class="doc_header"><code>fit_kde</code><a href="https://github.com/scribbler00/fastrenewables/tree/master/fastrenewables/synthetic_data.py#L30" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>fit_kde</code>(<strong><code>x</code></strong>, <strong><code>kernel</code></strong>=<em><code>'gaussian'</code></em>, <strong><code>bandwidth</code></strong>=<em><code>0.04</code></em>, <strong><code>x_min</code></strong>=<em><code>0</code></em>, <strong><code>x_max</code></strong>=<em><code>1</code></em>, <strong><code>n_x</code></strong>=<em><code>1000</code></em>, <strong><code>figsize</code></strong>=<em><code>(16, 9)</code></em>, <strong><code>show_plot</code></strong>=<em><code>False</code></em>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="calculate_kld" class="doc_header"><code>calculate_kld</code><a href="https://github.com/scribbler00/fastrenewables/tree/master/fastrenewables/synthetic_data.py#L45" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>calculate_kld</code>(<strong><code>p</code></strong>, <strong><code>q</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#</span>
<span class="c1">#class DummyDataset(torch.utils.data.Dataset):</span>
<span class="c1">#</span>
<span class="c1">#    def __init__(self, n_samples=1024, n_cat_feats=2, n_cont_feats=2, n_targets=1, len_ts=24, n_dim=2):</span>
<span class="c1">#</span>
<span class="c1">#        self.n_samples = n_samples</span>
<span class="c1">#        if n_dim == 2:</span>
<span class="c1">#            self.x_cat = torch.ones(n_samples, n_cat_feats)</span>
<span class="c1">#            self.x_cont = torch.ones(n_samples, n_cont_feats)</span>
<span class="c1">#            self.y = torch.ones(n_samples, n_targets)</span>
<span class="c1">#        elif n_dim == 3:</span>
<span class="c1">#            self.x_cat = torch.ones(n_samples, n_cat_feats, len_ts)</span>
<span class="c1">#            self.x_cont = torch.ones(n_samples, n_cont_feats, len_ts)</span>
<span class="c1">#            self.y = torch.ones(n_samples, n_targets, len_ts)</span>
<span class="c1">#        elif n_dim == 4:</span>
<span class="c1">#            self.x_cat = torch.ones(n_samples, n_cat_feats, len_ts, len_ts)</span>
<span class="c1">#            self.x_cont = torch.ones(n_samples, n_cont_feats, len_ts, len_ts)</span>
<span class="c1">#            self.y = torch.ones(n_samples, n_targets, len_ts, len_ts)</span>
<span class="c1">#</span>
<span class="c1">#    def __len__(self):</span>
<span class="c1">#        return self.n_samples</span>
<span class="c1">#    </span>
<span class="c1">#    def __getitem__(self, idx):</span>
<span class="c1">#        x_cat = self.x_cat[idx, :]</span>
<span class="c1">#        x_cont = self.x_cont[idx, :]</span>
<span class="c1">#        y = self.y[idx, :]</span>
<span class="c1">#        return x_cat, x_cont, y</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#</span>
<span class="c1">#n_dim = 2</span>
<span class="c1">#data = DummyDataset(n_dim=n_dim)</span>
<span class="c1">#dl = torch.utils.data.DataLoader(data, batch_size=batch_size, shuffle=True, drop_last=True)</span>
<span class="c1">#for x_cat, x_cont, y in dl:</span>
<span class="c1">#    assert(x_cat.dim()==x_cont.dim()==n_dim)</span>
<span class="c1">#</span>
<span class="c1">#n_dim = 3</span>
<span class="c1">#data = DummyDataset(n_dim=n_dim)</span>
<span class="c1">#dl = torch.utils.data.DataLoader(data, batch_size=batch_size, shuffle=True, drop_last=True)</span>
<span class="c1">#for x_cat, x_cont, y in dl:</span>
<span class="c1">#    assert(x_cat.dim()==x_cont.dim()==n_dim)</span>
<span class="c1">#</span>
<span class="c1">#n_dim = 4</span>
<span class="c1">#data = DummyDataset(n_dim=n_dim)</span>
<span class="c1">#dl = torch.utils.data.DataLoader(data, batch_size=batch_size, shuffle=True, drop_last=True)</span>
<span class="c1">#for x_cat, x_cont, y in dl:</span>
<span class="c1">#    assert(x_cat.dim()==x_cont.dim()==n_dim)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="GaussianDataset" class="doc_header"><code>class</code> <code>GaussianDataset</code><a href="https://github.com/scribbler00/fastrenewables/tree/master/fastrenewables/synthetic_data.py#L57" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>GaussianDataset</code>(<strong>*<code>args</code></strong>, <strong>**<code>kwds</code></strong>) :: <code>Dataset</code></p>
</blockquote>
<p>An abstract class representing a :class:<code>Dataset</code>.</p>
<p>All datasets that represent a map from keys to data samples should subclass
it. All subclasses should overwrite :meth:<code>__getitem__</code>, supporting fetching a
data sample for a given key. Subclasses could also optionally overwrite
:meth:<code>__len__</code>, which is expected to return the size of the dataset by many
:class:<code>~torch.utils.data.Sampler</code> implementations and the default options
of :class:<code>~torch.utils.data.DataLoader</code>.</p>
<p>.. note::
  :class:<code>~torch.utils.data.DataLoader</code> by default constructs a index
  sampler that yields integral indices.  To make it work with a map-style
  dataset with non-integral indices/keys, a custom sampler must be provided.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#</span>
<span class="c1">#class UniformDataset(torch.utils.data.Dataset):</span>
<span class="c1">#</span>
<span class="c1">#    def __init__(self, n_samples=1024, n_classes=2):</span>
<span class="c1">#        self.n_samples = n_samples</span>
<span class="c1">#        self.n_classes = n_classes</span>
<span class="c1">#        self.x_cat = torch.zeros(self.n_samples*self.n_classes, 1)</span>
<span class="c1">#        self.x_cont = torch.zeros(self.n_samples*self.n_classes, 1)</span>
<span class="c1">#        self.y = torch.zeros(self.n_samples*self.n_classes, 1)</span>
<span class="c1">#        self.mins = [0, 0, 0, 0]</span>
<span class="c1">#        self.maxs = [1, 1, 1, 1]</span>
<span class="c1">#        </span>
<span class="c1">#        self.generate_series()</span>
<span class="c1">#        self.x_cont = (self.x_cont-self.x_cont.min())/(self.x_cont.max()-self.x_cont.min())</span>
<span class="c1">#        </span>
<span class="c1">#    def generate_series(self):</span>
<span class="c1">#        for c in range(self.n_classes):</span>
<span class="c1">#            for idx in range(self.n_samples):</span>
<span class="c1">#                self.x_cat[c*self.n_samples + idx] = c+1</span>
<span class="c1">#                self.y[c*self.n_samples + idx] = c</span>
<span class="c1">#                self.x_cont[c*self.n_samples + idx] = torch.distributions.Uniform(self.mins[c], self.maxs[c]).rsample()</span>
<span class="c1">#        </span>
<span class="c1">#    def __len__(self):</span>
<span class="c1">#            return self.n_samples*self.n_classes</span>
<span class="c1">#</span>
<span class="c1">#    def __getitem__(self, idx):</span>
<span class="c1">#        x_cat = self.x_cat[idx, :]</span>
<span class="c1">#        x_cont = self.x_cont[idx, :]</span>
<span class="c1">#        y = self.y[idx, :]</span>
<span class="c1">#        return x_cat, x_cont, y</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#</span>
<span class="c1">#data = UniformDataset(n_samples=n_samples, n_classes=n_classes)</span>
<span class="c1">#dl = torch.utils.data.DataLoader(data, batch_size=batch_size, shuffle=True, drop_last=True)</span>
<span class="c1">#for x_cat, x_cont, y in dl:</span>
<span class="c1">#    break</span>
<span class="c1">#</span>
<span class="c1">#plot_class_hists(x_cat, x_cont)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#</span>
<span class="c1">#torch.pi = 3.141592653589793</span>
<span class="c1">#</span>
<span class="c1">#class SineDataset(torch.utils.data.Dataset):</span>
<span class="c1">#</span>
<span class="c1">#    def __init__(self, n_samples=1000, n_classes=2, n_features=1, len_ts=24, noise=0.05, n_dim=2):</span>
<span class="c1">#        self.n_samples = n_samples</span>
<span class="c1">#        self.n_classes = n_classes</span>
<span class="c1">#        self.n_features = n_features</span>
<span class="c1">#        self.len_ts = len_ts</span>
<span class="c1">#        self.amp_min = 0.25</span>
<span class="c1">#        self.amp_max = 0.75</span>
<span class="c1">#        self.freq_min = 1.0</span>
<span class="c1">#        self.freq_max = 3.0</span>
<span class="c1">#        self.phase_min = 0.0</span>
<span class="c1">#        self.phase_max = 2.0*torch.pi</span>
<span class="c1">#        self.noise = noise</span>
<span class="c1">#        self.cat_data = torch.zeros(self.n_samples*self.n_classes, 1, self.len_ts)</span>
<span class="c1">#        self.cont_data = torch.zeros(self.n_samples*self.n_classes, self.n_features, self.len_ts)</span>
<span class="c1">#        self.target = torch.zeros(self.n_samples*self.n_classes, 1, self.len_ts)</span>
<span class="c1">#        self.n_dim = n_dim</span>
<span class="c1">#        </span>
<span class="c1">#        self.generate_series()</span>
<span class="c1">#        self.cont_data = (self.cont_data-self.cont_data.min())/(self.cont_data.max()-self.cont_data.min())</span>
<span class="c1">#        if self.n_dim==2:</span>
<span class="c1">#            self.reshape_2d()</span>
<span class="c1">#        </span>
<span class="c1">#    def generate_series(self):</span>
<span class="c1">#        for c in range(self.n_classes):</span>
<span class="c1">#            t = torch.linspace(0, 1, self.len_ts)</span>
<span class="c1">#            amplitudes = torch.linspace(self.amp_min, self.amp_max, self.n_classes)</span>
<span class="c1">#            frequencies = torch.linspace(self.freq_min, self.freq_max, self.n_classes)</span>
<span class="c1">#            phases = torch.linspace(self.phase_min, self.phase_max, self.n_classes)</span>
<span class="c1">#            for idx in range(self.n_samples):</span>
<span class="c1">#                self.cat_data[c*self.n_samples + idx, :, :] = c+1</span>
<span class="c1">#                self.target[c*self.n_samples + idx, :, :] = c</span>
<span class="c1">#                for f_idx in range(self.n_features):</span>
<span class="c1">#                    a = torch.ones_like(t)*amplitudes[c]</span>
<span class="c1">#                    f = torch.ones_like(t)*frequencies[c]</span>
<span class="c1">#                    p = torch.ones_like(t)*phases[c]</span>
<span class="c1">#                    self.cont_data[c*self.n_samples + idx, f_idx, :] = a*torch.sin(2*torch.pi*f*t + p) + self.noise*torch.randn_like(t)</span>
<span class="c1">#                    </span>
<span class="c1">#    def reshape_2d(self):</span>
<span class="c1">#        #todo: check if this works with n_features &gt; 1</span>
<span class="c1">#        self.cat_data = self.cat_data.reshape(self.n_samples*self.n_classes*self.len_ts, 1)</span>
<span class="c1">#        self.cont_data = self.cont_data.reshape(self.n_samples*self.n_classes*self.len_ts, self.n_features)</span>
<span class="c1">#        self.target = self.target.reshape(self.n_samples*self.n_classes*self.len_ts, 1)</span>
<span class="c1">#        </span>
<span class="c1">#    def __len__(self):</span>
<span class="c1">#        if self.n_dim==2:</span>
<span class="c1">#            return self.n_samples*self.n_classes*self.len_ts</span>
<span class="c1">#        else:</span>
<span class="c1">#            return self.n_samples*self.n_classes</span>
<span class="c1">#</span>
<span class="c1">#    def __getitem__(self, idx):</span>
<span class="c1">#        x_cat = self.cat_data[idx, :]</span>
<span class="c1">#        x_cont = self.cont_data[idx, :]</span>
<span class="c1">#        y = self.target[idx, :]</span>
<span class="c1">#        return x_cat, x_cont, y</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#</span>
<span class="c1">#data = SineDataset(n_samples=n_samples, n_classes=n_classes, n_features=n_features, len_ts=len_ts, n_dim=n_dim)</span>
<span class="c1">#dl = torch.utils.data.DataLoader(data, batch_size=batch_size, shuffle=True, drop_last=True)</span>
<span class="c1">#for x_cat, x_cont, y in dl:</span>
<span class="c1">#    assert(x_cat.min() == 1 and x_cat.max() == n_classes)</span>
<span class="c1">#    assert(x_cont.max() &lt;= 1 and x_cont.min() &gt;= 0)</span>
<span class="c1">#    if n_dim==2:</span>
<span class="c1">#        assert(x_cat.shape == (batch_size, 1))</span>
<span class="c1">#        assert(x_cont.shape) == (batch_size, n_features)</span>
<span class="c1">#        assert(y.shape == (batch_size, 1))</span>
<span class="c1">#    if n_dim==3:</span>
<span class="c1">#        assert(x_cat.shape == (batch_size, 1, len_ts))</span>
<span class="c1">#        assert(x_cont.shape) == (batch_size, n_features, len_ts)</span>
<span class="c1">#        assert(y.shape == (batch_size, 1, len_ts))</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#</span>
<span class="c1">#def plot_sine_samples(dl):</span>
<span class="c1">#    plt.figure(figsize=(16, 9))</span>
<span class="c1">#    for _, x_cont, _ in dl:</span>
<span class="c1">#        for idx in range(x_cont.shape[0]):</span>
<span class="c1">#            plt.plot(x_cont[idx, 0, :])</span>
<span class="c1">#    plt.show()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#</span>
<span class="c1">#plot_sine_samples(dl)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

</div>
 

